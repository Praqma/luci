runDockerCompose(){
   #$1 is path to Compose file
   composeRoot=$1
   runZettaTools -v $composeRoot:/tmp/context docker-compose -f /tmp/context/docker-compose.yml up -d
}

stopDockerCompose(){
   #$1 is path to Compose file
   composeRoot=$1
   runZettaTools -v $composeRoot:/tmp/context docker-compose -f /tmp/context/docker-compose.yml stop
}


buildDockerImage() {
   #$1 is the path to the context folder of the image.
   #eg. $LUCI_ROOT/src/main/remotedocker/jenkins-slaves/shell/context/
   #$2 is the name of the image.
   contextRoot=$1
   imageName=$2
   runZettaTools -v $contextRoot:/tmp/context docker build -t $imageName /tmp/context
}

createDockerKeyImage() {
   #$1 is the path to the folder that holds the ssh keys.
   #$2 is the name of the image.
   keyDir=$1
   imageName=$2
   runZettaTools docker create -v $keydir/id_rsa.pub:/data/server-keys/authorized_keys $imageName
}

isContainerRunning(){
  local containerId=$1
  local answer=$(runZettaTools docker inspect --format '{{ .State.Running }}' $containerId)
  if [ "$answer" == "true" ];then
    return 0
  else
    return 1
  fi
}


dockerLogs(){
  #This code is a replacement for docker logs -f
  #This code is not complete. It will print some lines out twice. This
  #needs to be fixed.

  #Argument 1 is container id to be logged
  local cid=$1
  local timeStamp

  while true; do
    local nextTime=$(date +%s)
    runZettaTools docker logs --since=$timeStamp $cid 2>&1

    #This line is nessasary for the process to die, when the function proccessLines dies
    echo "### LUCI $(date)"
    if [ $(runZettaTools docker inspect --format='{{.State.Running}}' $cid) = "false" ]; then
        runZettaTools docker inspect $cid
        runZettaTools docker logs $cid
        return 0
    fi

    timeStamp=$nextTime
    sleep 2
  done
}

createSshKeyDataContainer(){
    local jdcidReturnVar=$1
    local keydir=$2
    local keyComment=$3
    local dataImageLocation=$4
    local dataImageName=$5

    #We generate new SSH-keys into the tmpdir subfolder "keys" These are then Unsed
    #by the data container to supply both the Jenkins server and slave
    generateSshKey $keydir "$keyComment"

    #The data image is build and the container is created to house the SSH-keys
    buildDockerImage $dataImageLocation $dataImageName

    local _jdcidVal=$(createDockerKeyImage $keydir luci-data)
    cleanup_container $_jdcidVal

    eval "$jdcidReturnVar=$_jdcidVal"

}
